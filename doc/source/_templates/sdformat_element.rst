{% set mod_parts = fullname.split(".") %}
{% for mod_part in mod_parts %}
{% set path = ".".join(mod_parts[:loop.index]) %}
{% if mod_part == "bindings" %}

{% set mod_path = ".".join(mod_parts[:loop.index]) %}
{% set sdf_version = mod_parts[loop.index] %}
{% set class_path = ".".join(mod_parts[(loop.index):]) %}
{% set top_class = mod_parts[loop.index + 2] %}
{% set sdf_ver = sdf_version[0] + sdf_version[1] + "." + sdf_version[2:] %}


{{ class_path | escape | underline}}

{% set link = "http://sdformat.org/spec?ver=" + sdf_ver[1:] + "&elem=" + top_class.lower() %}
{% if loop.index + 2 != mod_parts | length - 1 %}
{% set link = link + "#" + mod_parts[-2].lower() + "_" + mod_parts[-1].lower() %}
{% endif%}

.. warning::
    This class is autogenerated. More detailed documentation can be found in the
    `SDFormat spec <{{link}}>`_.

.. autoclass:: {{ mod_path }}::{{ class_path }}

{# Recursively generate nested classes #}
{# Cuz who needs :recursive: anyway B-) xD #}
.. currentmodule:: {{ mod_path }}

{% set sub_classes = members | reject("eq", "Meta") | reject("lower") %}
{% for el in sub_classes %}
{% if loop.first %}
.. rubric:: {{_("Nested Elements")}}

Note that only complex elements are listed here. Elements that resolve to simple
types (int, str, bool) are inlined.

.. autosummary::
    :template: sdformat_element.rst
    :toctree:
{% endif %}

    {{ class_path }}.{{ el }}
{% endfor %}

{% endif %}
{% endfor %}