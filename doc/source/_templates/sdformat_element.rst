{% set mod_parts = fullname.split(".") %}
{% for mod_part in mod_parts %}
{% set path = ".".join(mod_parts[:loop.index]) %}
{% if mod_part == "bindings" %}

{% set mod_path = ".".join(mod_parts[:loop.index + 1]) %}
{% set sdf_version = mod_parts[loop.index] %}
{% set class_path = ".".join(mod_parts[(loop.index + 1):]) %}
{% set sdf_ver = sdf_version[0] + sdf_version[1] + "." + sdf_version[2:] %}


{% set document_title = sdf_version+"."+class_path %}
{{ document_title | escape | underline}}

.. warning::
    This class is autogenerated. More detailed documentation can be found in the
    `SDFormat spec <http://sdformat.org/spec?ver={{ sdf_ver[1:] }}>`_.

.. autoclass:: {{ mod_path }}::{{ class_path }}

{% if attributes %}
.. rubric:: {{_("Attributes")}}

{% for element in attributes %}
{{element}} : (see typehint in signature above)
    This attribute represents an XML attribute or child element.
{% endfor %}
{% endif %}

{# Recursively generate nested classes #}
{# Cuz who needs :recursive: anyway B-) xD #}
{% set sub_classes = members | reject("eq", "Meta") | reject("lower") %}
{% for el in sub_classes %}
{% if loop.first %}
.. rubric:: {{_("Nested Classes")}}

A nested class, too, represents an element of SDFormat. However, it can only
ever occur as a child of this class.

.. currentmodule:: {{ mod_path }}

.. autosummary::
    :template: sdformat_element.rst
    :toctree:
{% endif %}

    {{ class_path }}.{{ el }}
{% endfor %}

{% endif %}
{% endfor %}